<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SafeWalking: New Haven Crime-Aware Navigation</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.10);
      --panel-2: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted-2: rgba(255,255,255,0.55);

      --brand1: #7c3aed; /* violet */
      --brand2: #2563eb; /* blue */
      --brand3: #06b6d4; /* cyan */

      --good: #22c55e;
      --warn: #eab308;
      --bad: #f97316;
      --danger: #ef4444;

      --shadow: 0 20px 60px rgba(0,0,0,0.45);
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.30);

      --radius-xl: 20px;
      --radius-lg: 14px;
      --radius-md: 12px;
      --radius-sm: 10px;
    }

    *{ margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; }

    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(124,58,237,0.25), transparent 60%),
        radial-gradient(900px 700px at 90% 20%, rgba(37,99,235,0.25), transparent 60%),
        radial-gradient(900px 700px at 50% 100%, rgba(6,182,212,0.20), transparent 60%),
        var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    /* Header */
    header{
      padding: 24px 32px 18px 56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(8, 12, 26, 0.6);
      backdrop-filter: blur(14px);
    }


    .brand{
      display:flex; align-items:center; gap:12px;
      margin-left: 24px;
    }

    .logo{
      width:40px; height:40px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--brand1), var(--brand2));
      display:grid; place-items:center;
      box-shadow: 0 10px 25px rgba(37,99,235,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      user-select:none;
    }

    .logo span{
      font-size: 18px;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
    }

    header h1{
      font-size: 16px;
      letter-spacing: 0.2px;
      line-height: 1.2;
      margin-bottom: 2px;
      font-weight: 750;
    }
    header p{
      font-size: 12px;
      color: var(--muted);
    }

    .header-actions{
      display:flex; gap:10px; align-items:center;
    }

    .chip{
      display:flex; align-items:center; gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      font-size: 12px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--warn);
      box-shadow: 0 0 0 4px rgba(234,179,8,0.18);
    }

    /* Layout */
    .container{
      height: calc(100vh - 73px);
      display:grid;
      grid-template-columns: 380px 1fr;
    }

    .sidebar{
      padding: 18px;
      overflow:auto;
      border-right: 1px solid rgba(255,255,255,0.10);
      background: rgba(8, 12, 26, 0.55);
      backdrop-filter: blur(14px);
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-soft);
      padding: 14px;
      margin-bottom: 14px;
    }

    .card-title{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom: 10px;
    }

    .card-title h2{
      font-size: 13px;
      font-weight: 750;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.92);
    }

    .badge{
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      white-space: nowrap;
    }

    /* Instructions */
    .instructions{
      display:grid;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .instructions strong{
      color: rgba(255,255,255,0.92);
      font-size: 12px;
    }
    .steps{
      display:grid;
      gap: 6px;
      margin-top: 6px;
    }
    .step{
      display:flex; gap:10px; align-items:flex-start;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .step-num{
      width:22px; height:22px; border-radius: 7px;
      background: linear-gradient(135deg, rgba(124,58,237,0.45), rgba(37,99,235,0.45));
      border: 1px solid rgba(255,255,255,0.14);
      display:grid; place-items:center;
      font-size: 12px; color: rgba(255,255,255,0.92);
      flex: 0 0 auto;
      margin-top: 1px;
    }

    /* Loading */
    #loadingIndicator{
      display:none;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
    }
    .loading-pill{
      display:flex; align-items:center; gap:10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(37,99,235,0.18);
      border: 1px solid rgba(37,99,235,0.35);
    }
    .spinner{
      width: 16px; height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.22);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 1s linear infinite;
    }
    @keyframes spin{ to { transform: rotate(360deg); } }

    /* Inputs */
    .control-group{
      display:grid;
      gap: 8px;
      margin-bottom: 12px;
    }
    label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    input{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      outline: none;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      transition: transform 0.08s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input::placeholder{ color: rgba(255,255,255,0.38); }
    input:focus{
      border-color: rgba(124,58,237,0.55);
      box-shadow: 0 0 0 4px rgba(124,58,237,0.16);
    }

    /* Buttons */
    .btn-row{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 6px;
    }

    .btn{
      width: 100%;
      border: none;
      border-radius: 16px;
      padding: 12px 12px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 750;
      letter-spacing: 0.2px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      transition: transform 0.12s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      user-select:none;
    }

    .btn-icon{
      display: none;   /* removes it from layout entirely */
    }


    .btn-primary{
      background: linear-gradient(135deg, var(--brand1), var(--brand2));
      color: rgba(255,255,255,0.95);
      box-shadow: 0 14px 35px rgba(37,99,235,0.22);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .btn-primary:hover{
      transform: translateY(-1px);
      box-shadow: 0 18px 45px rgba(37,99,235,0.26);
    }
    .btn-secondary{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.88);
    }
    .btn-secondary:hover{ transform: translateY(-1px); }
    .btn:disabled{
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }
    .btn-icon{
      width: 18px; height: 18px;
      display:inline-grid; place-items:center;
      filter: drop-shadow(0 8px 14px rgba(0,0,0,0.25));
    }

    /* Legend */
    .legend-grid{
      display:grid;
      gap: 10px;
      margin-top: 8px;
    }
    .legend-item{
      display:flex;
      align-items:center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      padding: 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .legend-swatch{
      width: 14px;
      height: 14px;
      border-radius: 5px;
      box-shadow: 0 0 0 4px rgba(255,255,255,0.06);
      flex: 0 0 auto;
    }

    /* Route info */
    #routeInfo{ display:none; }
    .stats{
      display:grid;
      gap: 8px;
      margin-top: 8px;
    }
    .stat{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      color: var(--muted);
    }
    .stat b{
      color: rgba(255,255,255,0.92);
      font-size: 12px;
    }
    .safety-score{
      margin-top: 10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      display:flex; align-items:center; gap: 12px;
    }
    .safety-indicator{
      width: 14px; height: 14px; border-radius: 50%;
      background: var(--warn);
      box-shadow: 0 0 0 5px rgba(234,179,8,0.18);
      flex: 0 0 auto;
    }
    .safety-text{
      display:grid;
      gap: 2px;
    }
    .safety-text .small{
      font-size: 11px;
      color: var(--muted-2);
    }
    .safety-text .big{
      font-weight: 800;
      letter-spacing: 0.2px;
      font-size: 13px;
    }

    /* Methodology note */
    .note{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.45;
    }
    .note strong{
      color: rgba(255,255,255,0.92);
      display:block;
      margin-bottom: 6px;
      font-size: 12px;
    }

    /* Map */
    #map{
      position: relative;
    }
    .map-overlay{
      position:absolute;
      top: 14px;
      right: 14px;
      z-index: 999;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      max-width: 380px;
    }
    .pill{
      display:flex; align-items:center; gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.90);
      font-size: 12px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.30);
    }
    .pill .mini-dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--brand3);
      box-shadow: 0 0 0 4px rgba(6,182,212,0.18);
    }

    /* Leaflet tweaks */
    .leaflet-control-zoom a{
      background: rgba(0,0,0,0.45) !important;
      color: rgba(255,255,255,0.92) !important;
      border: 1px solid rgba(255,255,255,0.12) !important;
      backdrop-filter: blur(10px);
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip{
      background: rgba(10, 14, 28, 0.92) !important;
      color: rgba(255,255,255,0.92) !important;
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
    }
    .leaflet-popup-content{
      margin: 10px 12px !important;
      font-size: 12px;
      line-height: 1.35;
    }

    /* Responsive: sidebar becomes bottom sheet */
    @media (max-width: 920px){
      body{ overflow:auto; }
      .container{
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
        height: auto;
        min-height: calc(100vh - 73px);
      }
      .sidebar{
        border-right: none;
        border-top: 1px solid rgba(255,255,255,0.10);
        max-height: 55vh;
      }
      #map{
        height: 55vh;
      }
    }
  </style>
</head>

<div class="brand">
    <div>
      <h1>SafeWalking: New Haven</h1>
      <p>Crime-aware routing</p>
    </div>
  </div>
  


    
    <header>
        <div class="brand">
          <div>
            <h1>Find the safest route using OpenStreetMap</h1>
            <p>A demo using safety factors of neighborhoods and randomness to simulate the real world </p>
          </div>
        </div>
      
        <div class="header-actions">
          <div class="chip">
            <span class="dot"></span>
            <span id="headerStatus">Ready</span>
          </div>
        </div>
      </header>
      

  <div class="container">
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">
          <h2>How to use</h2>
          <span class="badge">Demo-ready</span>
        </div>
        <div class="instructions">
          <strong>Quick steps</strong>
          <div class="steps">
            <div class="step">
              <div class="step-num">1</div>
              <div>Wait for streets to load from OpenStreetMap.</div>
            </div>
            <div class="step">
              <div class="step-num">2</div>
              <div>Click the map to set <b>Start</b> (green) and <b>End</b> (red).</div>
            </div>
            <div class="step">
              <div class="step-num">3</div>
              <div>Or type addresses below (New Haven area works best).</div>
            </div>
            <div class="step">
              <div class="step-num">4</div>
              <div>Click <b>Find Safest Route</b>.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="loadingIndicator" class="card">
        <div class="loading-pill">
          <div class="spinner"></div>
          <div style="display:grid; gap:2px;">
            <div style="font-weight:800; font-size:12px;">Loading street network…</div>
            <div style="font-size:11px; color: var(--muted);">Fetching data from Overpass API</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Route inputs</h2>
          <span class="badge">Click map or type</span>
        </div>

        <div class="control-group">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <label for="startInput">Start Address</label>
            <button id="useLocationBtn" class="location-btn" type="button" title="Use my current location" style="background: none; border: none; color: var(--muted); cursor: pointer; padding: 4px; display: flex; align-items: center; gap: 4px; font-size: 12px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
              </svg>
              <span>Use my location</span>
            </button>
          </div>
          <div style="position: relative;">
            <input type="text" id="startInput" placeholder="e.g., 149 York St, New Haven, CT" style="padding-right: 40px;" />
            <div id="locationSpinner" class="spinner" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); display: none; width: 16px; height: 16px; border-width: 2px;"></div>
          </div>
        </div>

        <div class="control-group">
          <label for="endInput">End Address</label>
          <input type="text" id="endInput" placeholder="e.g., 344 College St, New Haven, CT" />
        </div>

        <div class="btn-row">
            <button class="btn btn-primary" onclick="findSafestRoute()" id="findRouteBtn">
              Find Safest Route
            </button>
            <button class="btn btn-secondary" onclick="clearRoute()">
              Clear Route
            </button>
            <button class="btn btn-secondary" onclick="loadStreetData()">
              Reload Street Data
            </button>
          </div>          
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Street safety legend</h2>
          <span class="badge">Colors match map</span>
        </div>

        <div class="legend-grid">
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--good);"></div>
            <div>Safe <span style="color:var(--muted-2);">(0–2 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--warn);"></div>
            <div>Moderate <span style="color:var(--muted-2);">(3–5 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--bad);"></div>
            <div>Unsafe <span style="color:var(--muted-2);">(6–8 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--danger);"></div>
            <div>Very Unsafe <span style="color:var(--muted-2);">(9+ crimes)</span></div>
          </div>
        </div>
      </div>

      <div id="routeInfo" class="card">
        <div class="card-title">
          <h2>Route summary</h2>
          <span class="badge" id="routeBadge">Calculated</span>
        </div>

        <div class="stats">
          <div class="stat">
            <span>Distance</span>
            <b id="routeDistance">-</b>
          </div>
          <div class="stat">
            <span>Total Crime Score</span>
            <b id="routeCrimeScore">-</b>
          </div>
          <div class="stat">
            <span>Segments</span>
            <b id="routeSegments">-</b>
          </div>
        </div>

        <div class="safety-score">
          <div class="safety-indicator" id="safetyIndicator"></div>
          <div class="safety-text">
            <div class="small">Safety Rating</div>
            <div class="big" id="safetyRating">-</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Methodology</h2>
          <span class="badge">Hackathon model</span>
        </div>
        <div class="note">
          <strong>How scores are generated</strong>
          Streets are loaded from OpenStreetMap. Crime patterns are modeled using neighborhood-level safety factors
          (e.g., East Rock/Westville lower; Fair Haven/Newhallville higher), then applied per street segment.
          For a “real data” upgrade, you can swap the model for an open crime dataset and aggregate incidents to segments.
        </div>
      </div>
    </aside>

    <main id="map">
      <div class="map-overlay">
        <div class="pill">
          <span class="mini-dot" id="mapDot"></span>
          <span id="mapPillText">Street network: loading…</span>
        </div>
      </div>
    </main>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // Initialize map (centered on New Haven, CT - Yale area)
    const map = L.map('map').setView([41.3083, -72.9279], 14);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Graph structure
    let graph = { nodes: [], edges: [] };

    // Markers and layers
    let startMarker = null;
    let endMarker = null;
    let startPoint = null;
    let endPoint = null;
    let clickCount = 0;
    let streetLayers = [];
    let routeLayer = null;

    // Define New Haven neighborhoods with relative safety levels
    const neighborhoods = [
      { center: [41.3190, -72.9240], name: "East Rock", safeFactor: 0.3 },
      { center: [41.3180, -72.9420], name: "Westville", safeFactor: 0.4 },
      { center: [41.3083, -72.9279], name: "Downtown", safeFactor: 1.2 },
      { center: [41.3000, -72.9150], name: "Wooster Square", safeFactor: 0.5 },
      { center: [41.3250, -72.9080], name: "Fair Haven", safeFactor: 1.5 },
      { center: [41.3290, -72.9340], name: "Newhallville", safeFactor: 1.8 },
      { center: [41.3140, -72.9480], name: "Dwight", safeFactor: 1.6 },
      { center: [41.3050, -72.9400], name: "Hill", safeFactor: 1.4 }
    ];

    // UI helpers
    function setStatus(loading, text){
      const headerStatus = document.getElementById('headerStatus');
      const mapPillText = document.getElementById('mapPillText');
      const mapDot = document.getElementById('mapDot');

      headerStatus.textContent = text;
      mapPillText.textContent = text;

      if(loading){
        mapDot.style.background = '#eab308';
        mapDot.style.boxShadow = '0 0 0 4px rgba(234,179,8,0.18)';
      }else{
        mapDot.style.background = '#06b6d4';
        mapDot.style.boxShadow = '0 0 0 4px rgba(6,182,212,0.18)';
      }
    }

    // Load street data from OpenStreetMap Overpass API
    async function loadStreetData() {
      document.getElementById('loadingIndicator').style.display = 'block';
      document.getElementById('findRouteBtn').disabled = true;
      setStatus(true, 'Street network: loading…');

      // Clear existing data
      streetLayers.forEach(layer => map.removeLayer(layer));
      streetLayers = [];
      graph = { nodes: [], edges: [] };

      // Define bounding box for New Haven area (roughly 2km x 2km around center)
      const bbox = { south: 41.298, west: -72.943, north: 41.318, east: -72.913 };

      // Overpass API query for roads
      const query = `
        [out:json][timeout:25];
        (
          way["highway"~"^(motorway|trunk|primary|secondary|tertiary|residential|living_street|unclassified)$"]
          (${bbox.south},${bbox.west},${bbox.north},${bbox.east});
        );
        out body;
        >;
        out skel qt;
      `;

      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query
        });

        const data = await response.json();

        // Process OSM data
        const osmNodes = {};
        const ways = [];

        // First pass: collect all nodes
        data.elements.forEach(element => {
          if (element.type === 'node') {
            osmNodes[element.id] = { lat: element.lat, lon: element.lon };
          }
        });

        // Second pass: collect all ways
        data.elements.forEach(element => {
          if (element.type === 'way' && element.nodes && element.nodes.length > 1) {
            ways.push({ id: element.id, nodes: element.nodes, tags: element.tags || {} });
          }
        });

        // Build our graph from OSM data
        const nodeMap = new Map(); // Map OSM node ID to our node ID
        let nodeIdCounter = 0;

        ways.forEach(way => {
          way.nodes.forEach(osmNodeId => {
            if (!nodeMap.has(osmNodeId) && osmNodes[osmNodeId]) {
              const osmNode = osmNodes[osmNodeId];
              graph.nodes.push({
                id: nodeIdCounter,
                lat: osmNode.lat,
                lng: osmNode.lon,
                osmId: osmNodeId
              });
              nodeMap.set(osmNodeId, nodeIdCounter);
              nodeIdCounter++;
            }
          });
        });

        // Create edges from ways
        ways.forEach(way => {
          for (let i = 0; i < way.nodes.length - 1; i++) {
            const fromOsmId = way.nodes[i];
            const toOsmId = way.nodes[i + 1];
            if (!osmNodes[fromOsmId] || !osmNodes[toOsmId]) continue;

            const fromId = nodeMap.get(fromOsmId);
            const toId = nodeMap.get(toOsmId);

            const fromNode = graph.nodes[fromId];
            const toNode = graph.nodes[toId];

            const midLat = (fromNode.lat + toNode.lat) / 2;
            const midLng = (fromNode.lng + toNode.lng) / 2;

            const crimes = getCrimeLevel(midLat, midLng);
            const distance = getDistance(fromNode.lat, fromNode.lng, toNode.lat, toNode.lng);

            graph.edges.push({
              from: fromId,
              to: toId,
              crimes: crimes,
              weight: crimes + distance * 100,
              wayId: way.id,
              streetName: way.tags.name || 'Unnamed Street'
            });
          }
        });

        console.log(`Loaded ${graph.nodes.length} nodes and ${graph.edges.length} edges`);
        visualizeStreets();

        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('findRouteBtn').disabled = false;

        setStatus(false, `Street network: ready (${graph.edges.length} segments)`);
        document.getElementById('headerStatus').textContent = 'Ready';

      } catch (error) {
        console.error('Error loading street data:', error);
        alert('Error loading street data. Please try again or reload the page.');
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('findRouteBtn').disabled = false;
        setStatus(false, 'Street network: error');
        document.getElementById('headerStatus').textContent = 'Error';
      }
    }

    // Helper function to calculate distance between two points
    function calcDist(lat1, lng1, lat2, lng2) {
      return Math.sqrt((lat1-lat2)**2 + (lng1-lng2)**2);
    }

    // Helper function to get crime level based on neighborhood
    function getCrimeLevel(lat, lng) {
      let minDist = Infinity;
      let safeFactor = 1.0;

      neighborhoods.forEach(n => {
        const dist = calcDist(lat, lng, n.center[0], n.center[1]);
        if (dist < minDist) {
          minDist = dist;
          safeFactor = n.safeFactor;
        }
      });

      const baseCrime = Math.floor(Math.random() * 8);
      const adjustedCrime = Math.min(14, Math.floor(baseCrime * safeFactor));
      return adjustedCrime;
    }

    // Get color based on crime count
    function getCrimeColor(crimes) {
      if (crimes <= 2) return '#22c55e';
      if (crimes <= 5) return '#eab308';
      if (crimes <= 8) return '#f97316';
      return '#ef4444';
    }

    // Get width based on crime count
    function getCrimeWidth(crimes) {
      if (crimes <= 2) return 2;
      if (crimes <= 5) return 3;
      if (crimes <= 8) return 4;
      return 5;
    }

    // Visualize all streets on the map
    function visualizeStreets() {
      streetLayers.forEach(layer => map.removeLayer(layer));
      streetLayers = [];

      graph.edges.forEach(edge => {
        const fromNode = graph.nodes[edge.from];
        const toNode = graph.nodes[edge.to];

        const line = L.polyline(
          [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]],
          { color: getCrimeColor(edge.crimes), weight: getCrimeWidth(edge.crimes), opacity: 0.7 }
        ).addTo(map);

        line.bindPopup(`
          <strong>${edge.streetName}</strong><br>
          Crimes: ${edge.crimes}<br>
          Safety: ${edge.crimes <= 2 ? 'Safe' : edge.crimes <= 5 ? 'Moderate' : edge.crimes <= 8 ? 'Unsafe' : 'Very Unsafe'}
        `);

        streetLayers.push(line);
      });
    }

    // Calculate distance between two points (Haversine formula)
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Find nearest node to a given point
    function findNearestNode(lat, lng) {
      let minDist = Infinity;
      let nearestNode = null;

      graph.nodes.forEach(node => {
        const dist = getDistance(lat, lng, node.lat, node.lng);
        if (dist < minDist) {
          minDist = dist;
          nearestNode = node;
        }
      });

      return nearestNode;
    }

    // Dijkstra's algorithm to find safest path
    function dijkstra(startNodeId, endNodeId) {
      const distances = {};
      const previous = {};
      const unvisited = new Set();

      graph.nodes.forEach(node => {
        distances[node.id] = Infinity;
        previous[node.id] = null;
        unvisited.add(node.id);
      });
      distances[startNodeId] = 0;

      while (unvisited.size > 0) {
        let currentNode = null;
        let minDist = Infinity;

        unvisited.forEach(nodeId => {
          if (distances[nodeId] < minDist) {
            minDist = distances[nodeId];
            currentNode = nodeId;
          }
        });

        if (currentNode === null || currentNode === endNodeId) break;

        unvisited.delete(currentNode);

        graph.edges.forEach(edge => {
          let neighbor = null;
          let weight = edge.weight;

          if (edge.from === currentNode) neighbor = edge.to;
          else if (edge.to === currentNode) neighbor = edge.from;

          if (neighbor !== null && unvisited.has(neighbor)) {
            const alt = distances[currentNode] + weight;
            if (alt < distances[neighbor]) {
              distances[neighbor] = alt;
              previous[neighbor] = currentNode;
            }
          }
        });
      }

      const path = [];
      let current = endNodeId;
      while (current !== null) {
        path.unshift(current);
        current = previous[current];
      }
      return path.length > 1 ? path : null;
    }

    // Find and display the safest route
    function findSafestRoute() {
      if (!startPoint || !endPoint) {
        alert('Please select both start and end points on the map or enter addresses!');
        return;
      }
      if (graph.nodes.length === 0) {
        alert('Street data not loaded yet. Please wait...');
        return;
      }

      const startNode = findNearestNode(startPoint.lat, startPoint.lng);
      const endNode = findNearestNode(endPoint.lat, endPoint.lng);
      const path = dijkstra(startNode.id, endNode.id);

      if (!path) {
        alert('No route found!');
        return;
      }

      if (routeLayer) map.removeLayer(routeLayer);

      const routeCoords = path.map(nodeId => {
        const node = graph.nodes[nodeId];
        return [node.lat, node.lng];
      });

      routeLayer = L.polyline(routeCoords, {
        color: '#60a5fa',
        weight: 6,
        opacity: 0.95,
        dashArray: '10, 8'
      }).addTo(map);

      let totalCrimes = 0;
      let totalDistance = 0;

      for (let i = 0; i < path.length - 1; i++) {
        const fromId = path[i];
        const toId = path[i + 1];

        const edge = graph.edges.find(e =>
          (e.from === fromId && e.to === toId) ||
          (e.to === fromId && e.from === toId)
        );

        if (edge) totalCrimes += edge.crimes;

        const fromNode = graph.nodes[fromId];
        const toNode = graph.nodes[toId];
        totalDistance += getDistance(fromNode.lat, fromNode.lng, toNode.lat, toNode.lng);
      }

      const miles = totalDistance * 0.621371;
      document.getElementById('routeDistance').textContent = `${miles.toFixed(2)} mi`;

      document.getElementById('routeCrimeScore').textContent = totalCrimes;
      document.getElementById('routeSegments').textContent = path.length - 1;

      const avgCrimes = totalCrimes / (path.length - 1);
      let safetyRating, safetyColor;

      if (avgCrimes <= 2) { safetyRating = 'Very Safe'; safetyColor = '#22c55e'; }
      else if (avgCrimes <= 5) { safetyRating = 'Safe'; safetyColor = '#eab308'; }
      else if (avgCrimes <= 8) { safetyRating = 'Moderate'; safetyColor = '#f97316'; }
      else { safetyRating = 'Caution Advised'; safetyColor = '#ef4444'; }

      document.getElementById('safetyRating').textContent = safetyRating;
      document.getElementById('safetyIndicator').style.backgroundColor = safetyColor;
      document.getElementById('routeInfo').style.display = 'block';

      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
    }

    // Clear route and markers
    function clearRoute() {
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
      if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
      startPoint = null;
      endPoint = null;
      clickCount = 0;
      document.getElementById('startInput').value = '';
      document.getElementById('endInput').value = '';
      document.getElementById('routeInfo').style.display = 'none';
    }

    // Geocode address to coordinates
    async function geocodeAddress(address) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?` +
          `q=${encodeURIComponent(address)}&format=json&limit=1&` +
          `bounded=1&viewbox=-73.1,41.5,-72.7,41.1`
        );
        const data = await response.json();

        if (data && data.length > 0) {
          return {
            lat: parseFloat(data[0].lat),
            lng: parseFloat(data[0].lon),
            display_name: data[0].display_name
          };
        }
        return null;
      } catch (error) {
        console.error('Geocoding error:', error);
        return null;
      }
    }

    // Handle map clicks
    map.on('click', async function(e) {
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      if (clickCount === 0) {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([lat, lng], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        startPoint = { lat, lng };

        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
          );
          const data = await response.json();
          if (data && data.display_name) {
            document.getElementById('startInput').value = data.display_name;
            startMarker.bindPopup(data.display_name);
          }
        } catch (error) {
          document.getElementById('startInput').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }

        clickCount = 1;
      } else {
        if (endMarker) map.removeLayer(endMarker);
        endMarker = L.marker([lat, lng], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        endPoint = { lat, lng };

        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
          );
          const data = await response.json();
          if (data && data.display_name) {
            document.getElementById('endInput').value = data.display_name;
            endMarker.bindPopup(data.display_name);
          }
        } catch (error) {
          document.getElementById('endInput').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }

        clickCount = 0;
      }
    });

    // Handle location button click
    document.getElementById('useLocationBtn').addEventListener('click', async function() {
      const spinner = document.getElementById('locationSpinner');
      const startInput = document.getElementById('startInput');
      
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser');
        return;
      }

      try {
        spinner.style.display = 'block';
        this.disabled = true;
        
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          });
        });

        const { latitude, longitude } = position.coords;
        startPoint = { lat: latitude, lng: longitude };
        
        // Update the map view
        map.setView([latitude, longitude], 16);
        
        // Add marker for current location
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([latitude, longitude], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        
        // Try to get the address
        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`
          );
          const data = await response.json();
          startInput.value = data.display_name || `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
          if (startMarker) startMarker.bindPopup(startInput.value);
        } catch (error) {
          startInput.value = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
        }
        
        clickCount = 1;
      } catch (error) {
        console.error('Error getting location:', error);
        alert('Unable to retrieve your location. Please make sure location services are enabled and try again.');
      } finally {
        spinner.style.display = 'none';
        this.disabled = false;
      }
    });
    
    // Handle address input
    document.getElementById('startInput').addEventListener('change', async function(e) {
      const address = e.target.value.trim();
      if (!address) return;

      const coords = address.split(',').map(s => parseFloat(s.trim()));
      if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([coords[0], coords[1]], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        startPoint = { lat: coords[0], lng: coords[1] };
        map.setView([coords[0], coords[1]], 14);
      } else {
        const result = await geocodeAddress(address);
        if (result) {
          if (startMarker) map.removeLayer(startMarker);
          startMarker = L.marker([result.lat, result.lng], {
            icon: L.divIcon({
              className: 'custom-marker',
              html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
              iconSize: [20, 20]
            })
          }).addTo(map);
          startMarker.bindPopup(result.display_name).openPopup();
          startPoint = { lat: result.lat, lng: result.lng };
          map.setView([result.lat, result.lng], 15);
        } else {
          alert('Could not find address. Please try a more specific address in New Haven, CT.');
        }
      }
    });

    document.getElementById('endInput').addEventListener('change', async function(e) {
      const address = e.target.value.trim();
      if (!address) return;

      const coords = address.split(',').map(s => parseFloat(s.trim()));
      if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
        if (endMarker) map.removeLayer(endMarker);
        endMarker = L.marker([coords[0], coords[1]], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        endPoint = { lat: coords[0], lng: coords[1] };
      } else {
        const result = await geocodeAddress(address);
        if (result) {
          if (endMarker) map.removeLayer(endMarker);
          endMarker = L.marker([result.lat, result.lng], {
            icon: L.divIcon({
              className: 'custom-marker',
              html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
              iconSize: [20, 20]
            })
          }).addTo(map);
          endMarker.bindPopup(result.display_name).openPopup();
          endPoint = { lat: result.lat, lng: result.lng };
        } else {
          alert('Could not find address. Please try a more specific address in New Haven, CT.');
        }
      }
    });

    // Load street data on page load
    loadStreetData();
  </script>
</body>
</html>

